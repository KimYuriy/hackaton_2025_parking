// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'places_table_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$PlacesTableEvents {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadAll,
    required TResult Function() loadOccupied,
    required TResult Function() loadAvailable,
    required TResult Function() loadBlocked,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadAll,
    TResult? Function()? loadOccupied,
    TResult? Function()? loadAvailable,
    TResult? Function()? loadBlocked,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadAll,
    TResult Function()? loadOccupied,
    TResult Function()? loadAvailable,
    TResult Function()? loadBlocked,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadAll value) loadAll,
    required TResult Function(_LoadOccupied value) loadOccupied,
    required TResult Function(_LoadAvailable value) loadAvailable,
    required TResult Function(_LoadBlocked value) loadBlocked,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadAll value)? loadAll,
    TResult? Function(_LoadOccupied value)? loadOccupied,
    TResult? Function(_LoadAvailable value)? loadAvailable,
    TResult? Function(_LoadBlocked value)? loadBlocked,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadAll value)? loadAll,
    TResult Function(_LoadOccupied value)? loadOccupied,
    TResult Function(_LoadAvailable value)? loadAvailable,
    TResult Function(_LoadBlocked value)? loadBlocked,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PlacesTableEventsCopyWith<$Res> {
  factory $PlacesTableEventsCopyWith(
          PlacesTableEvents value, $Res Function(PlacesTableEvents) then) =
      _$PlacesTableEventsCopyWithImpl<$Res, PlacesTableEvents>;
}

/// @nodoc
class _$PlacesTableEventsCopyWithImpl<$Res, $Val extends PlacesTableEvents>
    implements $PlacesTableEventsCopyWith<$Res> {
  _$PlacesTableEventsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PlacesTableEvents
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$LoadAllImplCopyWith<$Res> {
  factory _$$LoadAllImplCopyWith(
          _$LoadAllImpl value, $Res Function(_$LoadAllImpl) then) =
      __$$LoadAllImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadAllImplCopyWithImpl<$Res>
    extends _$PlacesTableEventsCopyWithImpl<$Res, _$LoadAllImpl>
    implements _$$LoadAllImplCopyWith<$Res> {
  __$$LoadAllImplCopyWithImpl(
      _$LoadAllImpl _value, $Res Function(_$LoadAllImpl) _then)
      : super(_value, _then);

  /// Create a copy of PlacesTableEvents
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadAllImpl implements _LoadAll {
  const _$LoadAllImpl();

  @override
  String toString() {
    return 'PlacesTableEvents.loadAll()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadAllImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadAll,
    required TResult Function() loadOccupied,
    required TResult Function() loadAvailable,
    required TResult Function() loadBlocked,
  }) {
    return loadAll();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadAll,
    TResult? Function()? loadOccupied,
    TResult? Function()? loadAvailable,
    TResult? Function()? loadBlocked,
  }) {
    return loadAll?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadAll,
    TResult Function()? loadOccupied,
    TResult Function()? loadAvailable,
    TResult Function()? loadBlocked,
    required TResult orElse(),
  }) {
    if (loadAll != null) {
      return loadAll();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadAll value) loadAll,
    required TResult Function(_LoadOccupied value) loadOccupied,
    required TResult Function(_LoadAvailable value) loadAvailable,
    required TResult Function(_LoadBlocked value) loadBlocked,
  }) {
    return loadAll(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadAll value)? loadAll,
    TResult? Function(_LoadOccupied value)? loadOccupied,
    TResult? Function(_LoadAvailable value)? loadAvailable,
    TResult? Function(_LoadBlocked value)? loadBlocked,
  }) {
    return loadAll?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadAll value)? loadAll,
    TResult Function(_LoadOccupied value)? loadOccupied,
    TResult Function(_LoadAvailable value)? loadAvailable,
    TResult Function(_LoadBlocked value)? loadBlocked,
    required TResult orElse(),
  }) {
    if (loadAll != null) {
      return loadAll(this);
    }
    return orElse();
  }
}

abstract class _LoadAll implements PlacesTableEvents {
  const factory _LoadAll() = _$LoadAllImpl;
}

/// @nodoc
abstract class _$$LoadOccupiedImplCopyWith<$Res> {
  factory _$$LoadOccupiedImplCopyWith(
          _$LoadOccupiedImpl value, $Res Function(_$LoadOccupiedImpl) then) =
      __$$LoadOccupiedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadOccupiedImplCopyWithImpl<$Res>
    extends _$PlacesTableEventsCopyWithImpl<$Res, _$LoadOccupiedImpl>
    implements _$$LoadOccupiedImplCopyWith<$Res> {
  __$$LoadOccupiedImplCopyWithImpl(
      _$LoadOccupiedImpl _value, $Res Function(_$LoadOccupiedImpl) _then)
      : super(_value, _then);

  /// Create a copy of PlacesTableEvents
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadOccupiedImpl implements _LoadOccupied {
  const _$LoadOccupiedImpl();

  @override
  String toString() {
    return 'PlacesTableEvents.loadOccupied()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadOccupiedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadAll,
    required TResult Function() loadOccupied,
    required TResult Function() loadAvailable,
    required TResult Function() loadBlocked,
  }) {
    return loadOccupied();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadAll,
    TResult? Function()? loadOccupied,
    TResult? Function()? loadAvailable,
    TResult? Function()? loadBlocked,
  }) {
    return loadOccupied?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadAll,
    TResult Function()? loadOccupied,
    TResult Function()? loadAvailable,
    TResult Function()? loadBlocked,
    required TResult orElse(),
  }) {
    if (loadOccupied != null) {
      return loadOccupied();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadAll value) loadAll,
    required TResult Function(_LoadOccupied value) loadOccupied,
    required TResult Function(_LoadAvailable value) loadAvailable,
    required TResult Function(_LoadBlocked value) loadBlocked,
  }) {
    return loadOccupied(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadAll value)? loadAll,
    TResult? Function(_LoadOccupied value)? loadOccupied,
    TResult? Function(_LoadAvailable value)? loadAvailable,
    TResult? Function(_LoadBlocked value)? loadBlocked,
  }) {
    return loadOccupied?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadAll value)? loadAll,
    TResult Function(_LoadOccupied value)? loadOccupied,
    TResult Function(_LoadAvailable value)? loadAvailable,
    TResult Function(_LoadBlocked value)? loadBlocked,
    required TResult orElse(),
  }) {
    if (loadOccupied != null) {
      return loadOccupied(this);
    }
    return orElse();
  }
}

abstract class _LoadOccupied implements PlacesTableEvents {
  const factory _LoadOccupied() = _$LoadOccupiedImpl;
}

/// @nodoc
abstract class _$$LoadAvailableImplCopyWith<$Res> {
  factory _$$LoadAvailableImplCopyWith(
          _$LoadAvailableImpl value, $Res Function(_$LoadAvailableImpl) then) =
      __$$LoadAvailableImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadAvailableImplCopyWithImpl<$Res>
    extends _$PlacesTableEventsCopyWithImpl<$Res, _$LoadAvailableImpl>
    implements _$$LoadAvailableImplCopyWith<$Res> {
  __$$LoadAvailableImplCopyWithImpl(
      _$LoadAvailableImpl _value, $Res Function(_$LoadAvailableImpl) _then)
      : super(_value, _then);

  /// Create a copy of PlacesTableEvents
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadAvailableImpl implements _LoadAvailable {
  const _$LoadAvailableImpl();

  @override
  String toString() {
    return 'PlacesTableEvents.loadAvailable()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadAvailableImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadAll,
    required TResult Function() loadOccupied,
    required TResult Function() loadAvailable,
    required TResult Function() loadBlocked,
  }) {
    return loadAvailable();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadAll,
    TResult? Function()? loadOccupied,
    TResult? Function()? loadAvailable,
    TResult? Function()? loadBlocked,
  }) {
    return loadAvailable?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadAll,
    TResult Function()? loadOccupied,
    TResult Function()? loadAvailable,
    TResult Function()? loadBlocked,
    required TResult orElse(),
  }) {
    if (loadAvailable != null) {
      return loadAvailable();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadAll value) loadAll,
    required TResult Function(_LoadOccupied value) loadOccupied,
    required TResult Function(_LoadAvailable value) loadAvailable,
    required TResult Function(_LoadBlocked value) loadBlocked,
  }) {
    return loadAvailable(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadAll value)? loadAll,
    TResult? Function(_LoadOccupied value)? loadOccupied,
    TResult? Function(_LoadAvailable value)? loadAvailable,
    TResult? Function(_LoadBlocked value)? loadBlocked,
  }) {
    return loadAvailable?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadAll value)? loadAll,
    TResult Function(_LoadOccupied value)? loadOccupied,
    TResult Function(_LoadAvailable value)? loadAvailable,
    TResult Function(_LoadBlocked value)? loadBlocked,
    required TResult orElse(),
  }) {
    if (loadAvailable != null) {
      return loadAvailable(this);
    }
    return orElse();
  }
}

abstract class _LoadAvailable implements PlacesTableEvents {
  const factory _LoadAvailable() = _$LoadAvailableImpl;
}

/// @nodoc
abstract class _$$LoadBlockedImplCopyWith<$Res> {
  factory _$$LoadBlockedImplCopyWith(
          _$LoadBlockedImpl value, $Res Function(_$LoadBlockedImpl) then) =
      __$$LoadBlockedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadBlockedImplCopyWithImpl<$Res>
    extends _$PlacesTableEventsCopyWithImpl<$Res, _$LoadBlockedImpl>
    implements _$$LoadBlockedImplCopyWith<$Res> {
  __$$LoadBlockedImplCopyWithImpl(
      _$LoadBlockedImpl _value, $Res Function(_$LoadBlockedImpl) _then)
      : super(_value, _then);

  /// Create a copy of PlacesTableEvents
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadBlockedImpl implements _LoadBlocked {
  const _$LoadBlockedImpl();

  @override
  String toString() {
    return 'PlacesTableEvents.loadBlocked()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadBlockedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadAll,
    required TResult Function() loadOccupied,
    required TResult Function() loadAvailable,
    required TResult Function() loadBlocked,
  }) {
    return loadBlocked();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadAll,
    TResult? Function()? loadOccupied,
    TResult? Function()? loadAvailable,
    TResult? Function()? loadBlocked,
  }) {
    return loadBlocked?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadAll,
    TResult Function()? loadOccupied,
    TResult Function()? loadAvailable,
    TResult Function()? loadBlocked,
    required TResult orElse(),
  }) {
    if (loadBlocked != null) {
      return loadBlocked();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadAll value) loadAll,
    required TResult Function(_LoadOccupied value) loadOccupied,
    required TResult Function(_LoadAvailable value) loadAvailable,
    required TResult Function(_LoadBlocked value) loadBlocked,
  }) {
    return loadBlocked(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadAll value)? loadAll,
    TResult? Function(_LoadOccupied value)? loadOccupied,
    TResult? Function(_LoadAvailable value)? loadAvailable,
    TResult? Function(_LoadBlocked value)? loadBlocked,
  }) {
    return loadBlocked?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadAll value)? loadAll,
    TResult Function(_LoadOccupied value)? loadOccupied,
    TResult Function(_LoadAvailable value)? loadAvailable,
    TResult Function(_LoadBlocked value)? loadBlocked,
    required TResult orElse(),
  }) {
    if (loadBlocked != null) {
      return loadBlocked(this);
    }
    return orElse();
  }
}

abstract class _LoadBlocked implements PlacesTableEvents {
  const factory _LoadBlocked() = _$LoadBlockedImpl;
}

/// @nodoc
mixin _$PlacesTableStates {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(List<ParkingPlaceModel> places) dataLoaded,
    required TResult Function() errorLoading,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(List<ParkingPlaceModel> places)? dataLoaded,
    TResult? Function()? errorLoading,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(List<ParkingPlaceModel> places)? dataLoaded,
    TResult Function()? errorLoading,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loading value) loading,
    required TResult Function(_DataLoaded value) dataLoaded,
    required TResult Function(_ErrorLoading value) errorLoading,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Loading value)? loading,
    TResult? Function(_DataLoaded value)? dataLoaded,
    TResult? Function(_ErrorLoading value)? errorLoading,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_DataLoaded value)? dataLoaded,
    TResult Function(_ErrorLoading value)? errorLoading,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PlacesTableStatesCopyWith<$Res> {
  factory $PlacesTableStatesCopyWith(
          PlacesTableStates value, $Res Function(PlacesTableStates) then) =
      _$PlacesTableStatesCopyWithImpl<$Res, PlacesTableStates>;
}

/// @nodoc
class _$PlacesTableStatesCopyWithImpl<$Res, $Val extends PlacesTableStates>
    implements $PlacesTableStatesCopyWith<$Res> {
  _$PlacesTableStatesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PlacesTableStates
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$LoadingImplCopyWith<$Res> {
  factory _$$LoadingImplCopyWith(
          _$LoadingImpl value, $Res Function(_$LoadingImpl) then) =
      __$$LoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadingImplCopyWithImpl<$Res>
    extends _$PlacesTableStatesCopyWithImpl<$Res, _$LoadingImpl>
    implements _$$LoadingImplCopyWith<$Res> {
  __$$LoadingImplCopyWithImpl(
      _$LoadingImpl _value, $Res Function(_$LoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of PlacesTableStates
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadingImpl implements _Loading {
  const _$LoadingImpl();

  @override
  String toString() {
    return 'PlacesTableStates.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(List<ParkingPlaceModel> places) dataLoaded,
    required TResult Function() errorLoading,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(List<ParkingPlaceModel> places)? dataLoaded,
    TResult? Function()? errorLoading,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(List<ParkingPlaceModel> places)? dataLoaded,
    TResult Function()? errorLoading,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loading value) loading,
    required TResult Function(_DataLoaded value) dataLoaded,
    required TResult Function(_ErrorLoading value) errorLoading,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Loading value)? loading,
    TResult? Function(_DataLoaded value)? dataLoaded,
    TResult? Function(_ErrorLoading value)? errorLoading,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_DataLoaded value)? dataLoaded,
    TResult Function(_ErrorLoading value)? errorLoading,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _Loading implements PlacesTableStates {
  const factory _Loading() = _$LoadingImpl;
}

/// @nodoc
abstract class _$$DataLoadedImplCopyWith<$Res> {
  factory _$$DataLoadedImplCopyWith(
          _$DataLoadedImpl value, $Res Function(_$DataLoadedImpl) then) =
      __$$DataLoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<ParkingPlaceModel> places});
}

/// @nodoc
class __$$DataLoadedImplCopyWithImpl<$Res>
    extends _$PlacesTableStatesCopyWithImpl<$Res, _$DataLoadedImpl>
    implements _$$DataLoadedImplCopyWith<$Res> {
  __$$DataLoadedImplCopyWithImpl(
      _$DataLoadedImpl _value, $Res Function(_$DataLoadedImpl) _then)
      : super(_value, _then);

  /// Create a copy of PlacesTableStates
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? places = null,
  }) {
    return _then(_$DataLoadedImpl(
      places: null == places
          ? _value._places
          : places // ignore: cast_nullable_to_non_nullable
              as List<ParkingPlaceModel>,
    ));
  }
}

/// @nodoc

class _$DataLoadedImpl implements _DataLoaded {
  const _$DataLoadedImpl({required final List<ParkingPlaceModel> places})
      : _places = places;

  final List<ParkingPlaceModel> _places;
  @override
  List<ParkingPlaceModel> get places {
    if (_places is EqualUnmodifiableListView) return _places;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_places);
  }

  @override
  String toString() {
    return 'PlacesTableStates.dataLoaded(places: $places)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DataLoadedImpl &&
            const DeepCollectionEquality().equals(other._places, _places));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_places));

  /// Create a copy of PlacesTableStates
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DataLoadedImplCopyWith<_$DataLoadedImpl> get copyWith =>
      __$$DataLoadedImplCopyWithImpl<_$DataLoadedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(List<ParkingPlaceModel> places) dataLoaded,
    required TResult Function() errorLoading,
  }) {
    return dataLoaded(places);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(List<ParkingPlaceModel> places)? dataLoaded,
    TResult? Function()? errorLoading,
  }) {
    return dataLoaded?.call(places);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(List<ParkingPlaceModel> places)? dataLoaded,
    TResult Function()? errorLoading,
    required TResult orElse(),
  }) {
    if (dataLoaded != null) {
      return dataLoaded(places);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loading value) loading,
    required TResult Function(_DataLoaded value) dataLoaded,
    required TResult Function(_ErrorLoading value) errorLoading,
  }) {
    return dataLoaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Loading value)? loading,
    TResult? Function(_DataLoaded value)? dataLoaded,
    TResult? Function(_ErrorLoading value)? errorLoading,
  }) {
    return dataLoaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_DataLoaded value)? dataLoaded,
    TResult Function(_ErrorLoading value)? errorLoading,
    required TResult orElse(),
  }) {
    if (dataLoaded != null) {
      return dataLoaded(this);
    }
    return orElse();
  }
}

abstract class _DataLoaded implements PlacesTableStates {
  const factory _DataLoaded({required final List<ParkingPlaceModel> places}) =
      _$DataLoadedImpl;

  List<ParkingPlaceModel> get places;

  /// Create a copy of PlacesTableStates
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DataLoadedImplCopyWith<_$DataLoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ErrorLoadingImplCopyWith<$Res> {
  factory _$$ErrorLoadingImplCopyWith(
          _$ErrorLoadingImpl value, $Res Function(_$ErrorLoadingImpl) then) =
      __$$ErrorLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ErrorLoadingImplCopyWithImpl<$Res>
    extends _$PlacesTableStatesCopyWithImpl<$Res, _$ErrorLoadingImpl>
    implements _$$ErrorLoadingImplCopyWith<$Res> {
  __$$ErrorLoadingImplCopyWithImpl(
      _$ErrorLoadingImpl _value, $Res Function(_$ErrorLoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of PlacesTableStates
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$ErrorLoadingImpl implements _ErrorLoading {
  const _$ErrorLoadingImpl();

  @override
  String toString() {
    return 'PlacesTableStates.errorLoading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ErrorLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(List<ParkingPlaceModel> places) dataLoaded,
    required TResult Function() errorLoading,
  }) {
    return errorLoading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(List<ParkingPlaceModel> places)? dataLoaded,
    TResult? Function()? errorLoading,
  }) {
    return errorLoading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(List<ParkingPlaceModel> places)? dataLoaded,
    TResult Function()? errorLoading,
    required TResult orElse(),
  }) {
    if (errorLoading != null) {
      return errorLoading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loading value) loading,
    required TResult Function(_DataLoaded value) dataLoaded,
    required TResult Function(_ErrorLoading value) errorLoading,
  }) {
    return errorLoading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Loading value)? loading,
    TResult? Function(_DataLoaded value)? dataLoaded,
    TResult? Function(_ErrorLoading value)? errorLoading,
  }) {
    return errorLoading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_DataLoaded value)? dataLoaded,
    TResult Function(_ErrorLoading value)? errorLoading,
    required TResult orElse(),
  }) {
    if (errorLoading != null) {
      return errorLoading(this);
    }
    return orElse();
  }
}

abstract class _ErrorLoading implements PlacesTableStates {
  const factory _ErrorLoading() = _$ErrorLoadingImpl;
}
